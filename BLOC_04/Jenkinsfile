// ===============================
// ‚úÖ Jenkinsfile complet et final (avec v√©rification de l'installation de Docker)
// ===============================

// Variables globales pour stocker les r√©sultats des tests
def unitTests = 0
def mlTests = 0
def integrationTests = 0

pipeline {
    agent {
        docker {
            image 'python:3.10-slim'
            args '-u root:root'
        }
    }
    
    environment {
        WORK_DIR = "BLOC_04"
        REPORT_DIR = "${WORK_DIR}/reports"
        UNIT_REPORT = "${REPORT_DIR}/unit"
        ML_REPORT = "${REPORT_DIR}/ml"
        INTEGRATION_REPORT = "${REPORT_DIR}/integration"
        DAG_ID = "etl_weather_dag"
    }
    
    stages {

        stage('Install dependencies') {
            steps {
                dir("${WORK_DIR}") {
                    sh '''
                        echo "üì¶ Installation des d√©pendances syst√®me (avec nettoyage du cache)..."
                        # On nettoie les listes apt pour forcer une mise √† jour fra√Æche
                        rm -rf /var/lib/apt/lists/*
                        
                        # Installation des paquets, y compris le client Docker
                        apt-get update && apt-get install -y --no-install-recommends gcc ssh curl docker.io
                        
                        echo "‚úÖ V√©rification de l'installation de Docker..."
                        # On v√©rifie que la commande 'docker' est bien install√©e ET dans le PATH
                        # Si ce n'est pas le cas, on fait √©chouer le build ici avec une erreur claire.
                        which docker || (echo "ERREUR: Le client Docker n'a pas √©t√© trouv√© apr√®s l'installation." && exit 1)
                        
                        echo "üêç Installation des d√©pendances Python..."
                        pip install --upgrade pip
                        pip install -r requirements.txt
                    '''
                }
            }
        }

        stage('Lint Code') {
            steps {
                dir("${WORK_DIR}") {
                    sh '''
                        echo "üîç V√©rification qualit√© du code..."
                        flake8 dags/ dags_ml/ --max-line-length=120 --extend-ignore=E501,W503 --count || true
                        pylint dags/*.py dags_ml/*.py --disable=C,R --exit-zero || true
                    '''
                }
            }
        }

        stage('Validate DAGs') {
            steps {
                dir("${WORK_DIR}") {
                    sh '''
                        echo "‚úÖ Validation syntaxe des DAGs..."
                        export PYTHONPATH=$PYTHONPATH:$WORKSPACE/${WORK_DIR}/plugins
                        python tests/ml/validate_dags.py || exit 1
                    '''
                }
            }
        }

        stage('Run unit tests - Data Pipeline') {
            steps {
                dir("${WORK_DIR}") {
                    sh '''
                        echo "üß™ Tests unitaires - Pipeline de donn√©es..."
                        export PYTHONPATH=$PYTHONPATH:$WORKSPACE/${WORK_DIR}/plugins
                        mkdir -p reports/unit
                        pytest tests/unit \
                            --junitxml=reports/unit/report.xml \
                            --html=reports/unit/report.html \
                            --self-contained-html \
                            -v
                    '''
                }
            }
        }

        stage('Run unit tests - ML Pipeline') {
            steps {
                dir("${WORK_DIR}") {
                    sh '''
                        echo "üß™ Tests unitaires - Pipeline ML..."
                        export PYTHONPATH=$PYTHONPATH:$WORKSPACE/${WORK_DIR}/plugins:$WORKSPACE/${WORK_DIR}/dags_ml
                        mkdir -p reports/ml
                        pytest tests/ml/test_weather_dags.py tests/ml/test_training_pipeline.py \
                            -m "not integration" \
                            --junitxml=reports/ml/report.xml \
                            --html=reports/ml/report.html \
                            --self-contained-html \
                            --cov=dags_ml \
                            --cov-report=xml:reports/ml/coverage.xml \
                            --cov-report=html:reports/ml/coverage_html \
                            -v
                    '''
                }
            }
        }

        stage('Run integration tests - ML') {
            steps {
                dir("${WORK_DIR}") {
                    sh '''
                        echo "üîó Tests d'int√©gration - ML..."
                        export PYTHONPATH=$PYTHONPATH:$WORKSPACE/${WORK_DIR}/plugins:$WORKSPACE/${WORK_DIR}/dags_ml
                        mkdir -p reports/integration
                        pytest tests/ml \
                            -m "integration" \
                            --junitxml=reports/integration/report.xml \
                            --html=reports/integration/report.html \
                            --self-contained-html \
                            -v || true
                    '''
                }
            }
        }

        stage('Generate Test Summary') {
            steps {
                dir("${WORK_DIR}") {
                    sh '''
                        mkdir -p reports/summary
                        echo "<html><body>Dummy Summary to prevent publishHTML error.</body></html>" > reports/summary/summary.html
                    '''
                }
            }
        }

        stage('Read Test Results') {
            steps {
                dir("${WORK_DIR}") {
                    script {
                        echo "üìä Lecture des r√©sultats des tests..."

                        def getTestCount = { String reportPath ->
                            try {
                                if (!fileExists(reportPath)) {
                                    echo "‚ö†Ô∏è Fichier introuvable : ${reportPath}"
                                    return 0
                                }
                                def reportContent = readFile(reportPath)
                                def matcher = (reportContent =~ /<testsuite[^>]* tests="(\d+)"/)
                                if (matcher.find()) {
                                    def count = matcher.group(1).toInteger()
                                    echo "   -> ${count} test(s) trouv√©s dans ${reportPath}"
                                    return count
                                } else {
                                    echo "   -> Aucun test trouv√© dans ${reportPath}"
                                    return 0
                                }
                            } catch (Exception e) {
                                echo "‚ùå Erreur lecture ${reportPath}: ${e.getMessage()}"
                                return 0
                            }
                        }

                        unitTests = getTestCount("reports/unit/report.xml")
                        mlTests = getTestCount("reports/ml/report.xml")
                        integrationTests = getTestCount("reports/integration/report.xml")
                    }
                }
            }
        }

        stage('Publish reports') {
            steps {
                junit allowEmptyResults: true, testResults: "${REPORT_DIR}/**/report.xml"
                publishHTML(target: [ reportDir: "${UNIT_REPORT}", reportFiles: "report.html", reportName: "Unit Tests - Data Pipeline", keepAll: true, alwaysLinkToLastBuild: true ])
                publishHTML(target: [ reportDir: "${ML_REPORT}", reportFiles: "report.html", reportName: "Unit Tests - ML Pipeline", keepAll: true, alwaysLinkToLastBuild: true ])
                publishHTML(target: [ reportDir: "${ML_REPORT}/coverage_html", reportFiles: "index.html", reportName: "Coverage Report - ML", keepAll: true, alwaysLinkToLastBuild: true ])
                publishHTML(target: [ reportDir: "${INTEGRATION_REPORT}", reportFiles: "report.html", reportName: "Integration Tests - ML", keepAll: true, alwaysLinkToLastBuild: true, allowMissing: true ])
                publishHTML(target: [ reportDir: "${REPORT_DIR}/summary", reportFiles: "summary.html", reportName: "Test Summary", keepAll: true, alwaysLinkToLastBuild: true, allowMissing: true ])
            }
        }

        stage('Trigger Airflow DAG via CLI') {
            steps {
                script {
                    echo "üöÄ D√©clenchement du DAG '${DAG_ID}' via la CLI Airflow..."
                    
                    def schedulerContainerName = "airflow-airflow-scheduler-1" 

                    echo "   -> Conteneur cible : ${schedulerContainerName}"

                    sh """
                        docker exec ${schedulerContainerName} airflow dags trigger ${DAG_ID}
                    """

                    echo "‚úÖ Commande de d√©clenchement pour le DAG '${DAG_ID}' envoy√©e via la CLI."
                }
            }
        }

    }

    post {
        success {
            echo "‚úÖ Pipeline termin√© avec succ√®s."
            script {
                emailext(
                    subject: "‚úÖ Tests r√©ussis - ${env.JOB_NAME} #${env.BUILD_NUMBER}",
                    body: """
                        <html>
                        <body>
                            <h2>‚úÖ Tests r√©ussis</h2>
                            <p><b>Projet</b> : ${env.JOB_NAME}</p>
                            <p><b>Build</b> : #${env.BUILD_NUMBER}</p>
                            <h3>üìä R√©sum√© des tests</h3>
                            <ul>
                                <li>Tests unitaires - Data Pipeline : ${unitTests} tests</li>
                                <li>Tests unitaires - ML Pipeline : ${mlTests} tests</li>
                                <li>Tests d'int√©gration : ${integrationTests} tests</li>
                            </ul>
                            <h3>üöÄ Airflow</h3>
                            <p>Le DAG <b>${DAG_ID}</b> a √©t√© d√©clench√© avec succ√®s via la CLI.</p>
                            <h3>üìÑ Rapports</h3>
                            <ul>
                                <li><a href="${env.BUILD_URL}Unit_20Tests_20-_20Data_20Pipeline/">Tests Data Pipeline</a></li>
                                <li><a href="${env.BUILD_URL}Unit_20Tests_20-_20ML_20Pipeline/">Tests ML Pipeline</a></li>
                                <li><a href="${env.BUILD_URL}Coverage_20Report_20-_20ML/">Couverture ML</a></li>
                                <li><a href="${env.BUILD_URL}Integration_20Tests_20-_20ML/">Tests Int√©gration</a></li>
                            </ul>
                        </body>
                        </html>
                    """,
                    to: 'enguyen.fr@gmail.com',
                    from: 'enguyen.fr@gmail.com',
                    mimeType: 'text/html'
                )
            }
        }

        failure {
            echo "‚ùå Des tests ont √©chou√©."
            script {
                emailext(
                    subject: "‚ùå √âchec des tests - ${env.JOB_NAME} #${env.BUILD_NUMBER}",
                    body: """
                        <html>
                        <body>
                            <h2>‚ùå √âchec des tests</h2>
                            <p><b>Projet</b> : ${env.JOB_NAME}</p>
                            <p><b>Build</b> : #${env.BUILD_NUMBER}</p>
                            <p>Le DAG Airflow <b>${DAG_ID}</b> n‚Äôa pas √©t√© d√©clench√©, car les tests ont √©chou√©.</p>
                            <p><a href="${env.BUILD_URL}console">Voir les logs Jenkins</a></p>
                        </body>
                        </html>
                    """,
                    to: 'enguyen.fr@gmail.com',
                    from: 'enguyen.fr@gmail.com',
                    mimeType: 'text/html'
                )
            }
        }

        cleanup {
            echo "üßπ Nettoyage final..."
            cleanWs()
        }
    }
}
