// 1. D√©clarer les variables en dehors du pipeline pour qu'elles soient accessibles partout
def unitTests = 0
def mlTests = 0
def integrationTests = 0

pipeline {
    agent {
        docker {
            image 'python:3.10-slim'
            args '-u root:root'
        }
    }
    
    environment {
        WORK_DIR = "BLOC_04"
        REPORT_DIR = "${WORK_DIR}/reports"
        UNIT_REPORT = "${REPORT_DIR}/unit"
        ML_REPORT = "${REPORT_DIR}/ml"
        INTEGRATION_REPORT = "${REPORT_DIR}/integration"
    }
    
    stages {
        // ... Vos stages 'Install dependencies', 'Lint Code', 'Validate DAGs', 'Run unit tests', etc.
        // ... restent exactement les m√™mes.
        // ...
        // ... (J'omets les stages pr√©c√©dents pour la clart√©)

        stage('Run integration tests - ML') {
            steps {
                dir("${WORK_DIR}") {
                    sh '''
                        echo "üîó Tests d'int√©gration - ML..."
                        export PYTHONPATH=$PYTHONPATH:$WORKSPACE/${WORK_DIR}/plugins:$WORKSPACE/${WORK_DIR}/dags_ml
                        mkdir -p reports/integration
                        pytest tests/ml \
                            -m "integration" \
                            --junitxml=reports/integration/report.xml \
                            --html=reports/integration/report.html \
                            --self-contained-html \
                            -v || true
                    '''
                }
            }
        }

        // =====================================================================
        // 2. NOUVEAU STAGE POUR LIRE LES R√âSULTATS AVANT LE NETTOYAGE
        // =====================================================================
        stage('Read Test Results') {
            steps {
                dir("${WORK_DIR}") {
                    script {
                        echo "üìä Lecture des r√©sultats des tests depuis les fichiers XML..."

                        def getTestCount = { String reportPath ->
                            try {
                                if (!fileExists(reportPath)) {
                                    echo "‚ö†Ô∏è Fichier de rapport introuvable : ${reportPath}"
                                    return 0
                                }
                                def reportContent = readFile(reportPath)
                                if (reportContent.trim().isEmpty()) {
                                    echo "‚ö†Ô∏è Fichier de rapport vide : ${reportPath}"
                                    return 0
                                }
                                def reportXml = new groovy.util.XmlSlurper().parseText(reportContent)
                                def count = reportXml.'**'.find { it.name() == 'testsuite' }.'@tests'.toInteger()
                                echo "   -> Trouv√© ${count} test(s) dans ${reportPath}"
                                return count
                            } catch (Exception e) {
                                echo "‚ùå Erreur d'analyse sur ${reportPath}: ${e.getMessage()}"
                                return 0
                            }
                        }

                        // Peupler les variables globales
                        unitTests = getTestCount("${REPORT_DIR}/unit/report.xml")
                        mlTests = getTestCount("${REPORT_DIR}/ml/report.xml")
                        integrationTests = getTestCount("${REPORT_DIR}/integration/report.xml")
                    }
                }
            }
        }

        stage('Publish reports') {
            // Ce stage ne change pas
            steps {
                junit allowEmptyResults: true, testResults: "${REPORT_DIR}/**/report.xml"
                publishHTML(target: [ reportDir: "${UNIT_REPORT}", reportFiles: "report.html", reportName: "Unit Tests - Data Pipeline", keepAll: true, alwaysLinkToLastBuild: true ])
                publishHTML(target: [ reportDir: "${ML_REPORT}", reportFiles: "report.html", reportName: "Unit Tests - ML Pipeline", keepAll: true, alwaysLinkToLastBuild: true ])
                publishHTML(target: [ reportDir: "${ML_REPORT}/coverage_html", reportFiles: "index.html", reportName: "Coverage Report - ML", keepAll: true, alwaysLinkToLastBuild: true ])
                publishHTML(target: [ reportDir: "${INTEGRATION_REPORT}", reportFiles: "report.html", reportName: "Integration Tests - ML", keepAll: true, alwaysLinkToLastBuild: true, allowMissing: true ])
                publishHTML(target: [ reportDir: "${REPORT_DIR}/summary", reportFiles: "summary.html", reportName: "Test Summary", keepAll: true, alwaysLinkToLastBuild: true ])
            }
        }
    }
    
    // =====================================================================
    // 3. BLOC POST SIMPLIFI√â UTILISANT LES VARIABLES
    // =====================================================================
    post {
        success {
            echo "‚úÖ Pr√©paration de l'e-mail de succ√®s avec les comptages d√©j√† lus."
            script {
                emailext(
                    subject: "‚úÖ Tests r√©ussis - ${env.JOB_NAME} #${env.BUILD_NUMBER}",
                    body: """
                        <html>
                        <body>
                            <h2>‚úÖ Tests r√©ussis</h2>
                            <p><b>Projet</b> : ${env.JOB_NAME}</p>
                            <p><b>Build</b> : #${env.BUILD_NUMBER}</p>
                            
                            <h3>üìä R√©sum√© des tests</h3>
                            <ul>
                                <li>Tests unitaires - Data Pipeline : ${unitTests} tests</li>
                                <li>Tests unitaires - ML Pipeline : ${mlTests} tests</li>
                                <li>Tests d'int√©gration : ${integrationTests} tests</li>
                            </ul>
                            
                            <h3>üìÑ Rapports</h3>
                            <ul>
                                <li><a href="${env.BUILD_URL}Unit_20Tests_20-_20Data_20Pipeline/">Tests Data Pipeline</a></li>
                                <li><a href="${env.BUILD_URL}Unit_20Tests_20-_20ML_20Pipeline/">Tests ML Pipeline</a></li>
                                <li><a href="${env.BUILD_URL}Coverage_20Report_20-_20ML/">Couverture ML</a></li>
                                <li><a href="${env.BUILD_URL}Integration_20Tests_20-_20ML/">Tests Int√©gration</a></li>
                            </ul>
                            
                            <p><i>Tous les tests ont √©t√© ex√©cut√©s avec succ√®s ! üéâ</i></p>
                            
                            <p>Cordialement,<br/>Jenkins CI</p>
                        </body>
                        </html>
                    """,
                    to: 'enguyen.fr@gmail.com',
                    from: 'enguyen.fr@gmail.com',
                    replyTo: 'enguyen.fr@gmail.com',
                    mimeType: 'text/html'
                )
            }
        }
        
        failure {
           // ... (votre bloc failure reste identique) ...
        }
        
        cleanup {
            // Le nettoyage se fait bien en tout dernier, apr√®s l'envoi de l'email.
            echo "üßπ Nettoyage final de l'espace de travail..."
            cleanWs()
        }
    }
}
